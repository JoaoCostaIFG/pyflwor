
PyQuery - The Python Object Query System
========================================

By Tim Henderson - tim.tadh@hackthology.com


Introducton
-----------

PyQuery is an query language for querying python object collections. While Python has many
interesting ways to persisting objects, it does not have (to my knowledge) a query language. This
language was inspired in part by OQL (Object Query Language), XPath2.0, and XQuery. It is still
under rapid development so expect the language to change often. PyQuery works on any type of Python
object. The only requirement being that the objects returned have to be hashable (as they are
currently returned as set).


Motivation
----------

The motivation for this work occured while working on a software system with a unified namespace to
address hetergenous data models. Some of the models were relational, some were XML, and increasingly
some were simply native python objects. To unify this namespace I am working on this language.
However, I expect that since PyQuery works on any Python object collection it may be generally
useful to the Python community.


Langauge
--------

The language syntax is based roughly on XPath. At the base of the language is a "Query" expression.
This returns a set of objects. Those objects can be heterogenous, but they all must be hashable.
Querying works much the same as it does in XPath. By using the "/" operator the query traverses down
the object heirarchy. For instance if one has an object like:
	% class A(object):
	%   def __init__(self, x):
	%     self.x = x
	% a = A('a string')

The query:
	% pyquery.execute("a/x", locals())

returns:
	% set(['a string'])

If an object is an iterable object when using the "/" operator instead of returning the object it
instead returns each *distinct* item in the iterable.
class A(object):
  def __init__(self, x):
    self.x = x
a = A(['a string', '2 string', '3 string', 'blue string'])

The query:
	% pyquery.execute("a/x", locals())

returns (in no particular order, since it is a set):
	% set(['a string', '2 string', '3 string', 'blue string'])

You can add where conditions to the query at any level:
	% pyquery.execute("a/x[self[0].isdigit()]", locals())

returns:
	% set(['2 string', '3 string'])

Where expressions can be quite powerful consider this tuple of tuples:
	% lists = ((1,2,3),(5,6,7),(8,9,10),(1,3,5),(2,4,6),(5,7,9),(6,8,10))

Here is a query to return lists which only have even elements:
	% pyquery.execute('lists[every item in <self> satisfies (item.__mod__(2) == 0)]', locals())

returns:
	% set([(2, 4, 6), (6, 8, 10)])

If now let us express the opposite query, by using set difference:
	% pyquery.execute('lists - lists[every item in <self> satisfies (item.__mod__(2) == 0)]', locals())

returns:
	% set([(8, 9, 10), (1, 3, 5), (5, 6, 7), (5, 7, 9), (1, 2, 3)])

----------------------
more examples to arrive ...

Grammar
-------

S' -> Set
Set -> Set DIFFERENCE UnionExpr
Set -> UnionExpr
UnionExpr -> UnionExpr UNION IntersectionExpr
UnionExpr -> IntersectionExpr
IntersectionExpr -> IntersectionExpr INTERSECTION Collection
IntersectionExpr -> Collection
Collection -> Query
Collection -> LPAREN Set RPAREN
Query -> Query_
Query_ -> Query_ SLASH Entity
Query_ -> Entity
Entity -> NAME
Entity -> NAME LSQUARE Where RSQUARE
Where -> OrExpr
OrExpr -> OrExpr OR AndExpr
OrExpr -> AndExpr
AndExpr -> AndExpr AND NotExpr
AndExpr -> NotExpr
NotExpr -> NOT BooleanExpr
NotExpr -> BooleanExpr
BooleanExpr -> CmpExpr
BooleanExpr -> QuantifiedExpr
BooleanExpr -> SetExpr
BooleanExpr -> Value
BooleanExpr -> LPAREN Where RPAREN
CmpExpr -> Value CmpOp Value
CmpOp -> EQ
CmpOp -> NQ
CmpOp -> LANGLE
CmpOp -> LE
CmpOp -> RANGLE
CmpOp -> GE
Value -> NUMBER
Value -> STRING
Value -> AttributeValue
AttributeValue -> AttributeValue DOT Attr
AttributeValue -> Attr
ParameterList -> ParameterList COMMA Value
ParameterList -> Value
Attr -> NAME
Attr -> NAME Call
Call -> Call Call_
Call -> Call_
Call_ -> Fcall
Call_ -> Dcall
Fcall -> LPAREN RPAREN
Fcall -> LPAREN ParameterList RPAREN
Dcall -> LSQUARE Value RSQUARE
QuantifiedExpr -> Quantifier NAME IN LANGLE Set RANGLE SATISFIES LPAREN Where RPAREN
Quantifier -> EVERY
Quantifier -> SOME
SetExpr -> Value IN LANGLE Set RANGLE
SetExpr -> Value NOT IN LANGLE Set RANGLE
SetExpr -> LANGLE Set RANGLE SUBSET LANGLE Set RANGLE
SetExpr -> LANGLE Set RANGLE SUPERSET LANGLE Set RANGLE
SetExpr -> LANGLE Set RANGLE PROPER SUBSET LANGLE Set RANGLE
SetExpr -> LANGLE Set RANGLE PROPER SUPERSET LANGLE Set RANGLE
SetExpr -> LANGLE Set RANGLE IS LANGLE Set RANGLE
SetExpr -> LANGLE Set RANGLE IS NOT LANGLE Set RANGLE
